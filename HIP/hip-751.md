---
hip: 751
**title: Lockable Fractional Amounts of Fungible Tokens on Hedera**
author: Sam Wood <sam.wood@toko.network>
working-group: Stephanie Yi <stephanie.yi@toko.network>, Eleonora Odorizzi <eleonora.odorizzi@toko.network>, Vicky Lio <vicky.lio@toko.network>
type: Standards Track
category: Service
needs-council-approval: Yes
superseded-by: 796
status: Replaced
created: 2023-06-07
updated: 2023-08-30
discussions-to: https://github.com/hashgraph/hedera-improvement-proposal/discussions/759
---

## Abstract

This Hedera Improvement Proposal (HIP) proposes a new feature to allow locking of a portion of fungible tokens on the Hedera network. This "lock" functionality is similar to the existing "pause" functionality described in HIP-24, but operates on a portion of the tokens instead of the entire supply. The creator of fungible tokens must be able to optionally set a lock key during deployment to activate this function. 

This feature will enable token issuers to temporarily halt the transfer or trading of specific tokens within a collection, while still allowing other tokens to remain active. This addition will provide both increased control and flexibility to token issuers, and enhance the overall usability and security of fungible tokens on the Hedera network.

## Motivation

Currently, the Hedera Token Service allows for the pausing of an entire supply of fungible tokens, but there is no way to perform this feature on individual tokens within a supply.

This is limiting for token issuers who need to temporarily halt the transfer or trading of a fractional amount of tokens for tax or regulatory compliance, security concerns, business requirements, or technical issues. 

By introducing the ability to lock partial quantities within the total supply, Hedera will provide increased control and flexibility to token issuers and enhance the overall usability and security of fungible tokens on the network, supporting use cases across different industries.

The ability to lock a portion of the supply is useful in scenarios, including but not limited to the following:

1. Temporarily restricting transfers of a partial number of fungible tokens during an auction lockout period.
2. Ensuring compliance with regulatory frameworks, law enforcement requests, or contractual obligations.
3. Temporarily locking a some amount of fungible tokens for maintenance or upgrades.
4. Locking only a partial amount of tokens to reduce token holder risk of losing the entire supply in case of any unforeseen events such as hacks or technical issues.
5. Restricting trading period to obtain preferential tax treatment

The implementation of the current freeze mechanism is inadequate in this context, as it results in the entire wallet being subjected to a state of suspended animation for this token ID. Our objective, however, is to enable the locking and unlocking of distinct portions of tokens within a single wallet, in a manner that is both efficient and effective. Creating separate wallets to hold different portions of the token supply is not a viable solution, especially given the  complexities associated with custodial matters.

As an example, suppose we have two groups of tokens (Token X) within a single supply: “tranche A” and “tranche B,” each with a unique set of unlocking conditions. With the introduction of the locking feature, we can now segregate these two groups of tokens  into distinct categories to allow for the independent unlocking of tranche B tokens, without interfering with the locked status of tranche A tokens. 

Suppose that at time t, 10 tokens are locked in tranche A and scheduled to be unlocked at time t + 5, and at time t + 1, 20 tokens are locked in tranche B and scheduled to be unlocked at time t + 6.

The proposed lock functionality would allow for and result in the following:


    Initially (time = t), only tranche A is locked so the locked supply group of TokenX is equal to the total number of tokens locked in both tranches:
    Locked supply group = 10

    At time = t + 1, the locked supply group of TokenX is equal to the total number of tokens locked in both tranches:
    Locked supply group = 10 + 20 = 30

    At time t + 5, the 10 tokens in tranche A are unlocked, so the locked supply group is reduced by 10:
    Locked supply group = 20

    At time t + 6, the 20 tokens in tranche B are unlocked, and the locked supply group is reduced to 0:
    Locked supply group = 0

By segregating the two portions of TokenX into distinct categories (tranche A and tranche B), we can independently lock and unlock tokens according to their respective conditions, without affecting the status of tokens in the other tranche. The locked supply group is adjusted accordingly as tokens are locked and unlocked.

## Discussion on Duration of Lock

In order to implement a duration-based token lock for a portion of the total supply, Hedera's system will require a precise countdown timer to accurately track the expiration of the lock period. Given that Hedera's scheduled transactions feature also requires a mechanism for tracking and executing transactions based on a predetermined time, it stands to reason that the implementation of an expiration timer for duration-based token locks should be feasible within the network's existing infrastructure.

Should an unlocking event occur prematurely, prior to its scheduled release, the transaction designated for the scheduled unlock ought to release only the remaining locked funds, rather than permitting the lock_supply to become negative.

An alternative course of action could involve segregating the storage of lock duration data from the Hedera network. By doing so, the Hedera network would only need to oversee the lock/unlock states of the token, thereby reducing the computational overhead required to monitor token transactions.

## Rationale

The ability to lock individual tokens within the total supply of fungible tokens provides increased flexibility to customize tokens to meet specific needs while maintaining a high-level of security and compliance. It enables them to temporarily halt the transfer or trading of specific tokens within the supply without affecting the entire supply. This temporary halt to the transfer or trading of specific tokens within the supply without affecting the entire supply will be especially useful in situations where token issuers need to quickly respond to security concerns, regulatory compliance, or technical issues without disrupting the overall functionality of the supply.

The implementation of this feature within the Hedera ecosystem necessitates a protocol layer solution, as opposed to a smart contract, to ensure accurate representation of token ownership within the ecosystem's token explorers and wallets. Failure to incorporate this functionality at the protocol layer would result in the presentation of the smart contract address, rather than the investor's wallet address, as the purported token owner, which would be insufficient.

## Feature Support in other Languages

ERC-1410

This token standard allows for tokens to be subdivided into partitions and manipulated individually, while still maintaining their identity as part of the overall token supply. Transfers will fail when tokens are locked as part of a partition.

ERC-20 Custom Escrow

The “VestingWallet” function and “TokenTimelock” function for ERC20 have a similar feature in that the smart contract will release the tokens to the beneficiary following a given vesting schedule. The vesting schedule is customizable. Any tokens transferred to this contract will follow the vesting schedule as if they were locked from the beginning. Lockable fungible tokens, like the "VestingWallet" function for ERC20, allow for customized vesting schedules, ensuring that transferred tokens follow a predetermined release plan.

These Ethereum smart contracts provide functionality akin to token locking but have a drawback: the tokens are held within the contract and do not appear in the investor's wallet until unlocked. This discrepancy can cause confusion and misrepresentation of the actual token holdings in wallet interfaces and exchanges.

Custom Staking/Liquidity Pool Smart Contracts

DeFi protocols like Uniswap offer liquidity mining programs where users can stake their tokens in an escrow contract for a period. Like the custom escrow contracts, these tokens do not show up in the user's wallet until unstaked, potentially complicating total holding tracking across platforms.

Claimable Balance

Stellar's claimable balance feature resembles token locking by reserving payments for recipients, preventing reclamation by senders. However, it has limitations compared to the proposed feature in this HIP. Creating and managing separate claimable balance records adds complexity. The release of claimable balances is limited to specific conditions, and visibility of locked tokens in user wallets is not inherently supported, potentially causing confusion about token holdings.

These approaches offer similar functionality to the proposed token locking mechanism, albeit with varying visibility, accessibility, and complexity levels. The Hedera Token Service's introduction of token locking will provide a standardized, easy-to-use, native mechanism for token holders to lock and unlock their tokens.

## User Stories

**_Scenario_** - _Token Issuer_: Token issuance with transfer lock enabled 

AS A _Token Issuer_,

I WANT to be able to enable the transfer lock to a portion of my fungible tokens as needed 

SO THAT I can control the transferability of tokens and avoid token holders trading and transferring during the lock up period or otherwise as needed.

AS A _Token Issuer_, 

I WANT to be able to lock a portion of my issued fungible tokens for maintenance or or other reasons as needed,

SO THAT I can ensure the integrity and security of the tokens.

AS A _Token Issuer_,

I WANT to be able to transfer unlock a portion of fungible token supply according to their respective unlocking conditions, 

SO THAT I can maintain control over the transferring of the token supply.

AS A _Token Issuer_,

I WANT to be able to set a transfer lock key and to activate the transfer lock function to a portion of my fungible token supply, 

SO THAT my tokens are customized to meet my specific needs, regulatory or otherwise.


**_Scenario_** - _Token Issuer_: Enabling customizable execution time for transfer lock on a portion of token supply 

AS A a _Token Issuer_,

I WANT to be able to implement a duration-based token transfer lock for a portion of the total supply, 

SO THAT so that I can ensure token holders can not trade the supply unless the lock time has expired. 

AS A _Token Issuer_,

I WANT to have the option to enable the transfer lock function for a portion of my fungible token supply with a predetermined execution time,

SO THAT I can schedule the unlocking of tokens in advance without the need for immediate manual execution.

**_Scenario_** -  _Token Issuer_: Executing native events on the locked portion of a token supply

AS A _Token Issuer_,

I WANT to be able to execute events (metadata update, mint, burn, transfers and more) on my token even when the lock functionality is enabled, 

SO THAT I can continue to manage and update my token as needed without disrupting its transfer lock state.

**_Scenario_** - _Token Issuer_: Adding the optional memo field to a lock transaction  

AS A _Token Issuer_,

I WANT to be able to include a memo field in lock and unlock transactions,

SO THAT I can provide contextual information about the purpose of the transaction and enhance transparency and accountability.


**_Scenario_** - _Token Holder_: Tokens with enabled transfer lock

AS A _Token Holder_,

I WANT to be able to have a transfer lock state on my fungible tokens 

SO THAT I can trade tokens only once the lockup period has expired and avoid breach of regulatory requirements.

AS A _Token Holder_, 

I WANT to be able to transfer lock a fraction of my fungible tokens to my wallet

SO THAT I can reduce the risk of losing my entire supply in case of any unforeseen events such as hacks, market volatility, or technical issues.

AS A _Token Holder_,

I WANT to be able to view the locked and unlocked status of my tokens in my wallet and via the chain explorer, 

SO THAT I can keep track of my holdings and make informed decisions about their use.

## Specification

The proposed feature will introduce a new function to the Hedera Token Service API that allows token issuers to lock or unlock a fractional amount of fungible tokens up to the total supply. This function will be accessible through the Hedera Token Service API and can be called by the token issuer using their lock key.

When a token is locked, it will not be transferable or tradeable by the locked wallet until it is unlocked. The function will take several parameters:

* the token ID of the fungible tokens; 
* the fractional amount of tokens to be locked or unlocked;
* the wallet that holds these tokens.

The locked status of a token will be stored on the Hedera Token Service and can be accessed by the token issuer through the API. Token issuers will also be able to view a list of locked tokens and their corresponding amounts. 

Introducing support for Lockable Fungible Tokens (LFT) on the Hedera network will enable more advanced use cases for fungible tokens that require locking and unlocking functionality. Examples of such use cases include:

* Time-based access: An LFT can be locked until a specific date or time, allowing access to a particular asset or service only after a predetermined period.
* Joint escrow: An LFT can be locked until multiple parties agree to unlock it, allowing for a virtual joint escrow of an asset. Joint escrow in an LFT enables the locking of an asset until multiple parties agree to unlock it. This provides an added layer of security for transactions.
* Conditional transfers: An LFT can be locked until certain conditions are met, such as the receipt of payment, completion of a task, or other criteria. This could be implemented via a smart contract that has the lock key.

As with other transaction types on the Hedera network, users will have the option to submit lock/unlock transactions with a predetermined execution time using scheduled transactions. 

Furthermore, memo fields may be appended to these transactions to provide contextual information regarding the transaction's purpose. One potential use case for the memo field would be to provide an explanation for why the tokens are being locked, offering greater transparency and accountability for the transaction. Another usage is to include a timestamp indicating when the tokens are expected to be unlocked.

The implementation of this lock functionality should encompass the capability to be executed on wallets that have yet to be associated with the corresponding token. The provision of this feature grants users the desirable capacity to exercise control over a predetermined quantity of tokens, effortlessly imposing a lock on the destination wallet, all without necessitating explicit token association by the wallet's owner.

## Implementation

To enable the lock and unlock functionality of fungible tokens, the creator of the fungible tokens is required to establish a lock key during its token deployment. This characteristic bears resemblance to that of the pause key. If the token does not currently have a lock key, the update token transaction will resolve to TOKEN_HAS_NO_LOCK_KEY.

The extent of the locked amount may exceed the current supply of the wallet. Upon the transfer of additional tokens into said wallet, the locked amount shall persist to ensure that the newly transferred tokens are also subject to locking.

When a user stakes their tokens, a portion of those tokens are typically locked up for a set amount of time as collateral. This locked amount may surpass the initial supply of tokens within the user's wallet. If the user receives additional tokens and transfers them to the same wallet, the locked amount will remain, thereby also locking the newly transferred tokens.

Furthermore, the unlocking of a quantity greater than the currently locked amount in the holder's wallet is also disallowed and will result in a UNLOCK_EXCEEDS_LOCKED_AMOUNT_IN_ACCOUNT error message, as it violates the consistency and integrity of the underlying data structure.

Notably, any locked amounts of fungible tokens can only be unlocked with the possession of the designated lock key. Wipe and burn operations can still be performed on locked tokens.

The following operation cannot be performed on the locked portion of fungible tokens and will result in a TOKEN_IS_LOCKED status.

* Transfering the tokens

Note that burning or wiping can still be performed even if the tokens are locked because the process does not require the tokens to be transferred or used in any way. Instead, the tokens are simply removed from the ledger, effectively destroying them and reducing the total supply. It is imperative that the tokens remain locked during the burn or wipe operations, as unlocking them could potentially allow for malicious transfer of the tokens to evade the intended destruction.

With lockable fungible tokens, it is possible to perform move operations between partitions within the same wallet [pending HIP], even when the tokens are locked. This feature offers flexibility and granular control over token management. It allows users to organize and categorize their tokens within partitions while honoring the lock constraints imposed on the tokens. It can be particularly useful for scenarios where tokens need to be allocated for specific purposes, or kept separate for accounting or regulatory reasons.

```
message TokenCreateTransactionBody {
    ...
    Key pauseKey = 22; // The key which can pause the token. If empty, pause is not possible.
    Key lockKey = 23; // [New] The key which can lock individual or fractional FTs. If empty, locking fractional FTs is not possible.
}

message TokenInfo {
    ...
    TokenPauseStatus pause_status = 24; // Specifies whether the token is paused or not. PauseNotApplicable is returned if pauseKey is not set.
    repeated LockedTokenInfo locked_token_info = 25; // [New] Indicates the list of locked token amounts and their address location. One entity per wallet location.
}

message LockedTokenInfo {
    uint64 token_amount = 1; // Amount locked.
    AccountID account_id = 2; // Location of locked tokens.
}

```

```

// LockToken locks tokens.
func LockToken(tokenID hedera.TokenID, amount int64, accountID hedera.AccountID) (hedera.TransactionID, error) {

	// Create a new transaction to lock the token
	tx, err := hedera.NewTokenLockTransaction().
		SetTokenID(tokenID).
		SetAmount(amount).
		SetAccountID(accountID).
		Execute(client)

	if err != nil {
		return hedera.TransactionID{}, err
	}

	// Sign and submit the transaction
	txID, err := tx.GetTransactionID().Execute(client)
	if err != nil {
		return hedera.TransactionID{}, err
	}

	// Return the transaction ID
	return txID, nil
}

// UnlockToken unlocks a tokens.
func UnlockToken(tokenID hedera.TokenID, amount int64, accountID hedera.AccountID) (hedera.TransactionID, error) {

	// Create a new transaction to unlock the token
	tx, err := hedera.NewTokenUnlockTransaction().
		SetTokenID(tokenID).
		SetAmount(amount).
		SetAccountID(accountID).
		Execute(client)

	if err != nil {
		return hedera.TransactionID{}, err
	}

	// Sign and submit the transaction
	txID, err := tx.GetTransactionID().Execute(client)
	if err != nil {
		return hedera.TransactionID{}, err
	}

	// Return the transaction ID
	return txID, nil
}

```

```
// Token lock transactions can be called with a string memo field, to record additional information about this transaction, for example, when these tokens are scheduled to be unlocked.
tx, err := hedera.NewTokenLockTransaction().
		SetTokenID(tokenID).
		SetAmount(amount).
		SetAccountID(accountID).
        SetTransactionMemo(“tokens will be unlocked 60 days from lock event”).
		Execute(client)

// Token lock transactions can be scheduled to be executed at a later time.
scheduleTransaction, err := hedera.NewScheduleCreateTransaction().
    SetScheduledTransaction(tx).
    SetExpirationTime(<time in the future>)
```

## Backward Compatibility

This feature is fully backward compatible with the existing fungible tokens on the Hedera network. Token issuers can choose to use the feature or continue to operate their tokens as they currently do.

## Security Implications

It is imperative for the explorers to clearly specify the lockability of a token and the precise time when funds are placed in a locked state. This measure is vital in preventing any deceitful attempts by individuals who might attempt to present their locked funds/proof of reserves as readily available to others.

## Open Issues

N/A

## References

HIP-24: Pause feature on Hedera Token Service

[https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-24.md](https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-24.md)

ERC-1410: Partially Fungible Token Standard [https://github.com/ethereum/eips/issues/1410](https://github.com/ethereum/eips/issues/1410) 

ERC-20 Vesting Wallet [https://docs.openzeppelin.com/contracts/4.x/api/finance#VestingWallet](https://docs.openzeppelin.com/contracts/4.x/api/finance#VestingWallet) 

ERC-20 Token Time Lock [https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#TokenTimelock](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#TokenTimelock) 

Liquidity Mining [https://docs.uniswap.org/contracts/v3/guides/liquidity-mining/overview](https://docs.uniswap.org/contracts/v3/guides/liquidity-mining/overview) 

Claimable Balances [https://developers.stellar.org/docs/encyclopedia/claimable-balances](https://developers.stellar.org/docs/encyclopedia/claimable-balances) 

## Copyright/license

This document is licensed under the Apache License, Version 2.0 -- see [LICENSE](../LICENSE) or (https://www.apache.org/licenses/LICENSE-2.0)
